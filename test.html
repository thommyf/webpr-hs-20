<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Function Tests</title>
  <!-- C:\Users\thomm\webpr -->
</head>

<body>
  <script>
    // const Person = name => {
    //   let age = 0;
    //   return {
    //     getAge: ()       => age,
    //     setAge: newAge   => age = newAge,
    //     getName: ()      => name,
    //     setName: newName => name = newName
    //   }
    // };

    // const me = Person("Myself");
    // me.setName("Sherlock");
    // document.writeln(me.getName() === "Sherlock");

    // const xs1_ = [1, 2, 3];
    // const xs2_ = [1, 2];
    // const xs3_ = [1, 2];
    // const xs4_ = [1];
    // const ys1_ = [1, 2, 3];
    // const ys2_ = [1, 3];
    // const ys3_ = [1, 2];
    // const ys4_ = [1];


    // Array.prototype.eq = function (x) {
    //   if (x.length !== this.length) {
    //     return false;
    //   }

    //   for (let i = 0; i < this.length; i++) {
    //     if (x[i] !== this[i]) {
    //       return false;
    //     }
    //   }

    //   return true;
    // }

    // console.log(xs1_.eq(ys1_) && !xs2_.eq(ys2_) && xs3_.eq(ys3_) && !xs3_.eq(ys4_) && !xs4_.eq(ys3_));

    // class Person {
    //   constructor(name) {
    //     this.name = name;
    //   }
    //   isCool() { return this.name.length > 3 };
    // }  

    // const p = new Person("Dierk");
    // // p.prototype.isCool = () => true;   
    // document.writeln(p.isCool());

    // class Person  { }
    // class Student { }

    // const s = new Student();
    // Object.setPrototypeOf(Student.prototype, Person.prototype);

    // document.writeln(s instanceof Person);


    // function Todo(text) {
    //   let done = false;
    //   const check = () => this.done = true;
    //   return {
    //     getText: () => text,
    //     isDone:  () => done,
    //     check:  check
    //   }
    // }

    // let todo = new Todo("buy milk");
    // todo.check();
    // document.writeln(todo.isDone());

    // function handle(callback) {
    //   return callback( [] );
    // }

    // document.writeln( handle( it => { it.push(1); return it; } ).length === 1 );
    //=============================================================================================================
    // 16a 
    //  const inc    = x => x + 1;
    //  const double = x => x * 2;

    // Function.prototype.then = func =>  {
    //   console.log(func()); 
    //   return func();

    // }

    // Function.prototype.then = function(callback, arg) {
    //   console.log("then aufgerufen");
    //   return callback();
    // }

    //  function then (x) { 
    //    compose(x);
    //  };
    // console.log("Ãœbung 1");
    // console.log(inc.then(double).then(double) (1));
    // console.log( inc.then(double).then(double) (1) === 8 );


    //=============================================================================================================
    //Aufgabe Q18a
    // const failSafe = param1 => callback => param2 => {
    //   try {
    //     return callback( param2 );
    //   }
    //   catch {
    //     return param1;
    //   }
    // }

    // const doError = x => { throw new Error() };
    // const errorCount = failSafe (1) (doError);

    //  console.log(failSafe (false) (x=>x) (true) && failSafe (true) (doError) (null) && errorCount(null) === 1);
    //=============================================================================================================

    // const Observable = value => {
    //   const listeners = [];
    //   return {
    //     onChange: callback => listeners.push(callback),
    //     getValue: () => value,
    //     setValue: val => {
    //       if (value === val) return;
    //       value = val;
    //       listeners.forEach(listener => listener(val));
    //     }
    //   }
    // };

    // const color = Observable('white');
    // let observed = null;
    // color.onChange( val => observed = val);

    // document.writeln(observed === color.getValue());
    //=============================================================================================================  
    // Q20 
    // const x_ = 5;
    // const y_ = 6;
    // const z_ = 7;

    // const Observable = value => {
    //   const listeners = [];
    //   return {
    //     onChange: callback => {
    //       listeners.push(callback);
    //       callback(value, value);
    //     },
    //     getValue: () => value,
    //     setValue: newValue => {
    //       if (value === newValue) return;
    //       const oldValue = value;
    //       value = newValue;
    //       listeners.forEach(callback => callback(value, oldValue));
    //     }
    //   }
    // };

    // let sum = 0;
    // const trackable = Observable(0);

    // trackable.onChange( val => sum += val );

    // trackable.setValue(x_); // values x_, y_, z_ are given. Do not override.
    // trackable.setValue(y_);
    // trackable.setValue(z_);

    // console.log(trackable.getValue());
    // document.writeln( trackable.getValue() === z_ && sum === x_ + y_ + z_ );
    //=============================================================================================================


    // const idPromise = x => new Promise( resolve => resolve(x));

    // // document.writeln(idPromise(1));
    // // idPromise(1)
    // //   .then( it => { document.writeln(it); return it; })
    // //   .then( it => document.writeln(it));

    // const writer = x => {
    //   document.writeln(x);
    //   return idPromise(x);
    // };
    // // const inc        = n => n +1;
    // const filterEven = n => n % 2 === 0 ? n : undefined;
    // // const filterEven = n => { if (n % 2 === 0) return n; else throw Error("not even") };

    // idPromise(1)
    //   .then( writer)
    //   .then( filterEven )
    //   .then( writer );

    //=============================================================================================================
    // Q24
    // const idPromise = x => new Promise  


    //=============================================================================================================
    // Q24a
    const NullSafe = x => {
      const isNullSafe = y => y && y.then;
      const maywrap = y => ___; // if y is not NullSafe yet, make it so
      return {
        then: fn => ___ // see(1)
      }
    };

    NullSafe(1).then(console.log); // will call the log
    NullSafe(null).then(console.log); // will not call the log
    NullSafe(2).then(x => null).then(console.log); // will not call the log

    // x_ and y_ are given. do not override.                                    
    NullSafe(x_)
      .then(x => x * 2) // must auto-promote
      .then(x => NullSafe(x)) // must not auto-promote
      .then(x => y_ = x + 1) // store value, check no double promotion
      .then(x => null) // jump over rest
      .then(x => x.mustNotBeCalled) !== null && y_ === x_ * 2 + 1


      
  </script>
</body>

<!-- QUIZ: Verschiedene Arten von Objekt Encoding:
  - {:Value} -->

</html>